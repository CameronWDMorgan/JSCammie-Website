<!-- setup basic html template with metadata etc: -->
<html>
<head>
    <title>Image History | JSCammie.com</title>
    <meta name="description" content="View your generated images and their details.">
    <meta name="keywords" content="AI, Image, Generator, History, Details">
    <meta name="author" content="JSCammie">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0">
    <link rel='stylesheet' href='/style.css'/>
    
    <%- include('../partials/_headerAll') %>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-K3KJJKS1R4"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K3KJJKS1R4');
    </script>
    
</head>
<body>

    <!-- get partials/_navigation: -->
    <%- include('../partials/_navigation') %>

    <div class="center-fully-no-flex" style="margin-bottom: 3rem;">
        <%- include('../partials/_bannerAdvert') %>
    </div>

    <div id="loadingTimeDiv" style="position: fixed; top: 0; right: 0; padding: 10px; background-color: #00000015; border-radius: 0 0 0 10px; z-index: 1000;">
        <p id="loadingTime">Loading...</p>
    </div>

    <script>
        // remove the loading screen when the page is fully loaded:
        window.addEventListener('load', function() {
            // get the loading screen element:
            const loadingTimeDiv = document.getElementById('loadingTimeDiv');
            // fade out the loading screen:
            loadingTimeDiv.style.opacity = 100;

            // make it so they can click through the loading screen to the content below it:
            loadingTimeDiv.style.pointerEvents = 'none';

            // get the load time element:
            const loadingTime = document.getElementById('loadingTime');
            // get the time it took to load the page:
            const loadingTimeMS = new Date().getTime() - window.performance.timing.navigationStart;
            // set the load time text to the time it took to load the page in seconds (3.54s for example):
            loadingTime.innerText = `Loaded in ${loadingTimeMS / 1000}s`;

            // remove the loading screen after 3 second:
            setTimeout(() => {

                setTimeout(() => {
                    loadingTime.remove();
                    document.getElementById('loadingTimeDiv').remove();
                }, 5000);
            }, 5000);
        });
    </script>

    <div class="overlay" id="overlay"></div>
    <div class="booruPopupContent" id="booruPopupContent">
        <button class="closeButton" onclick="closeBooruPopup()">×</button>
        <!-- The content of the popup will be inserted here by JavaScript -->
    </div>
    <div class="generationPopupContent" id="generationPopupContent">
        <button class="closeButton" onclick="closeGenerationPopup()">×</button>
        <!-- The content of the popup will be inserted here by JavaScript -->
    </div>
    
    <div class="container round-frosted page-content mw75-dynamic" style="padding: 40px; justify-content: center;">
        <h1>Image History</h1>
    
        <script>  
            // Helper function to handle image click based on delete mode
            function handleImageClick(image_id, event) {
                if (deleteMode) {
                    toggleImageSelection(image_id, event);
                } else {
                    showGenerationPopup(image_id);
                }
            }

            function openInGenerator(image_id) {
                // `https://jscammie.com/?prompt=${booruImage.prompt}&negativeprompt=${booruImage.negative_prompt}&aspectRatio=${booruImage.aspect_ratio}&model=${booruImage.model}&steps=${booruImage.steps}&cfguidance=${booruImage.cfg}&seed=${booruImage.seed}&loras=[${booruImage.loras}]&lora_strengths=[${booruImage.lora_strengths}]`

                // get the imageData from the masterImageData object:
                const imageData = masterImageData[image_id];

                let url = `https://jscammie.com/?prompt=${encodeURIComponent(imageData.prompt)}&negativeprompt=${imageData.negative_prompt}&aspectRatio=${imageData.aspect_ratio}&model=${imageData.model}&steps=${imageData.steps}&cfguidance=${imageData.cfg}&seed=${imageData.seed}&loras=[${imageData.loras}]&lora_strengths=[${imageData.lora_strengths}]&`;

                window.open(url, '_blank')
            }

            async function uploadToBooru(image_id) {

                console.log(`Uploading image ${image_id} to booru`);

                // get the imageData from the masterImageData object:
                const imageData = masterImageData[image_id];

                let booruData = {
                    prompt: `${imageData.prompt}`,
                    negative_prompt: `${imageData.negative_prompt}`,
                    aspect_ratio: `${imageData.aspect_ratio}`,
                    model: `${imageData.model}`,
                    loras: `${imageData.loras}`,
                    lora_strengths: `${imageData.lora_strengths}`,
                    steps: `${imageData.steps}`,
                    cfg: `${imageData.cfg}`,
                    seed: `${imageData.seed}`,
                    image_url: `${imageData.image_url}`
                }

                // post req to create-booru-image:

                fetch('/create-booru-image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(booruData)
                })
                .then(response => response.json())
                .then(async data => {
                    console.log(data);

                    let options = {
                        message: data.message,
                        question: false,
                    }

                    let userResponse = await globalAlert(options)

                    if (data.status == 'success') {
                        // close the image and booru popup:
                        closeGenerationPopup();
                        closeBooruPopup();
                    } else {
                        // close the popup:
                        closeGenerationPopup();
                        closeBooruPopup();
                    }
                    
                })

            }

            function showBooruPopup(image_id) {
                // get the imageData from the masterImageData object:
                const imageData = masterImageData[image_id];
    
                const booruPopupContent = document.getElementById('booruPopupContent');
                const overlay = document.getElementById('overlay');

                // if they click off the popup, close it:
                overlay.onclick = function() {
                    closeGenerationPopup();
                    closeBooruPopup();
                }

                // 4a. While "Aged Up" content is allowed it needs to be clear from just looking at the image that they are over 18 with their proportions, outfit & general looks, they also MUST be 100% fictional and not based on anyone from real-life.
    
                booruPopupContent.innerHTML = `
                    <button class="closeButton" onclick="closeBooruPopup()">×</button>
                    <h1>Upload to Booru</h1>
                    <p>By uploading to the booru you agree to the following:</p>
                    <ul>
                        <li>Child/Cub/Loli NSFW content are NOT ALLOWED!!!</li>
                        <br>
                        <li>Aged-Up Characters that look over the age of 18 are allowed, if they do not look over 18, the post will be removed!</li>
                        <br>
                        <li>By default all content is hidden until a moderator approves it and gives it a safety rating (sfw, suggestive, nsfw).</li>
                        <br>
                        <li>ALL SETTINGS used to create an image are visible, if your content shows a word like "loli", even if its sfw, it will be removed!</li>
                        <br>
                        <li>Quality Generations are prefered! (Don't upload a billion variations ^-^;)
                    </ul>
                    <p>If you agree to these rules/terms then feel free to click below</p>
                    <button id="uploadToBooruButton" onclick="uploadToBooru('${image_id}')">Upload to Booru</button>
                `;

                document.getElementById('overlay').style.display = 'block';
                document.getElementById('booruPopupContent').style.display = 'block';
    
                // Listen for the ESC key to close the popup
                document.addEventListener('keydown', escCloseBooruPopup);
            }

            // Function to show the popup
            function showGenerationPopup(image_id) {
                // get the imageData from the masterImageData object:
                const imageData = masterImageData[image_id];
    
                const generationPopupContent = document.getElementById('generationPopupContent');
                const overlay = document.getElementById('overlay');

                // if they click off the popup, close it:
                overlay.onclick = function() {
                    closeGenerationPopup();
                }

                uploadToBooruButtonHTML = ``;

                // <button id="uploadToBooruButton" onclick="showBooruPopup('${image_id}')">Upload to Booru</button>
                //     <br>

                // add the above only if the image has not been uploaded to the booru yet:
                if (imageData.uploadedToBooru == false) {
                    uploadToBooruButtonHTML = `<button id="uploadToBooruButton" onclick="showBooruPopup('${image_id}')">Upload to Booru</button><br><br>`;
                }
    
                generationPopupContent.innerHTML = `
                    <button class="closeButton" onclick="closeGenerationPopup()">×</button>
                    <img class="popupGeneratedImage" src="${imageData.image_url}"></img>
                    
                    <br>
                    <br>
                    <button id="exportAIDataButton" onclick="exportAIData('${image_id}')">Export AI Data</button>
                    <br>
                    <br>
                    ${uploadToBooruButtonHTML}

                    <a>Prompt: </a>
                    <a id="prompt">${imageData.prompt}</a><br>

                    <a>Negative Prompt: </a>
                    <a id="negative_prompt">${imageData.negative_prompt}</a><br>

                    <a>Model: </a>
                    <a id="model">${imageData.model}</a><br>

                    <a>Aspect Ratio: </a>
                    <a id="aspect_ratio">${imageData.aspect_ratio}</a><br>

                    <a>LORAs: </a>
                    <a id="loras">${imageData.loras}</a><br>

                    <a>LORA Strengths: </a>
                    <a id="lora_strengths">${imageData.lora_strengths}</a><br>

                    <a>Steps: </a>
                    <a id="steps">${imageData.steps}</a><br>

                    <a>CFG: </a>
                    <a id="cfg">${imageData.cfg}</a><br>

                    <a>Seed: </a>
                    <a id="seed">${imageData.seed}</a><br>

                `;

                document.getElementById('overlay').style.display = 'block';
                document.getElementById('generationPopupContent').style.display = 'block';
    
                // Listen for the ESC key to close the popup
                document.addEventListener('keydown', escClosePopup);
            }

            // close booru popup:
            function closeBooruPopup() {
                const booruPopupContent = document.getElementById('booruPopupContent');
                const overlay = document.getElementById('overlay');
    
                booruPopupContent.style.display = 'none';
                overlay.style.display = 'none';
    
                // Remove the ESC key event listener
                document.removeEventListener('keydown', escCloseBooruPopup);
            }
    
            // Function to close the popup
            function closeGenerationPopup() {
                const generationPopupContent = document.getElementById('generationPopupContent');
                const overlay = document.getElementById('overlay');
    
                generationPopupContent.style.display = 'none';
                overlay.style.display = 'none';

                // Remove the ESC key event listener
                document.removeEventListener('keydown', escClosePopup);
            }
    
            // Function to close the popup with the ESC key

            function escCloseBooruPopup(event) {
                if (event.key === 'Escape') {
                    closeBooruPopup();
                }
            }

            function escClosePopup(event) {
                if (event.key === 'Escape') {
                    closeGenerationPopup();
                }
            }


            function exportAIData(image_id) {

                // get the imageData from the masterImageData object:
                const imageData = masterImageData[image_id];

                // Get the AI data from the form
                let aiData = {
                    prompt: imageData.prompt,
                    negativeprompt: imageData.negative_prompt,
                    aspectRatio: imageData.aspect_ratio,
                    model: imageData.model,
                    loras: imageData.loras,
                    lora_strengths: imageData.lora_strengths,
                    steps: imageData.steps,
                    quantity: 2,
                    cfg: imageData.cfg,
                    seed: imageData.seed,
                }

                // save it to a file and download it without jsyaml:
                let yamlString = `${aiData.prompt}<SPLIT>${aiData.negativeprompt}<SPLIT>${aiData.aspectRatio}<SPLIT>${aiData.model}<SPLIT>${aiData.loras}<SPLIT>${aiData.lora_strengths}<SPLIT>${aiData.steps}<SPLIT>${aiData.quantity}<SPLIT>${aiData.cfg}<SPLIT>${aiData.seed}`

                let blob = new Blob([yamlString], {type: 'text/yaml'});
                let url = URL.createObjectURL(blob);
                let a = document.createElement('a');
                a.href = url;
                a.download = `${aiData.model}.aidata`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }

        </script>
    
        <script>
            var masterImageData = {} 

            <% userHistory.forEach(imageData => { %>
                masterImageData["<%=imageData.image_id%><%=imageData.account_id%>"] = {
                    prompt: `<%=imageData.prompt%>`,
                    negative_prompt: `<%=imageData.negative_prompt%>`,
                    model: "<%=imageData.model%>",
                    aspect_ratio: "<%=imageData.aspect_ratio%>",
                    loras: "<%=imageData.loras%>",
                    lora_strengths: "<%=imageData.lora_strengths%>",
                    steps: "<%=imageData.steps%>",
                    cfg: "<%=imageData.cfg%>",
                    seed: "<%=imageData.seed%>",
                    image_url: "<%=imageData.image_url%>",
                    image_id: "<%=imageData.image_id%>",
                    uploadedToBooru: <%=imageData.uploadedToBooru%>,
                    thumbnailMade: <%=imageData.thumbnailMade%>,
                };
            <% }); %>
        </script>

        <script>

            async function deleteImage(div_id) {

                let options = {
                    message: 'Are you sure you want to delete this image?',
                    question: true,
                    options: {
                        yes: function() {
                            console.log("Yes clicked");
                        },
                        no: function() {
                            console.log("No clicked");
                        }
                    }
                }

                let alertResponse = await globalAlert(options);

                if (alertResponse == 'no') {
                    return;
                }

                // get the image_id and account_id from the image_id:
                let image_id_split = div_id.split('-');
                let image_id = image_id_split[0];
                let account_id = image_id_split[1];

                // get the image div:
                let imageDiv = document.getElementById(image_id + account_id);

                // send a request to the server to delete the image from the database:
                fetch('/image-history/delete-image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image_id: image_id,
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log(data);
                    // animate the image div disappearing:
                    imageDiv.style.transition = 'opacity 0.5s';
                    imageDiv.style.opacity = 0;
                    setTimeout(() => {
                        imageDiv.style.display = 'none';
                    }, 500);
                })
                .catch((error) => {
                    console.error('Error:', error);
                });
            }

        </script>

    <style>

        .closeButton {
            display: none;
        }

        .generationsGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            justify-content: center;
            width: 100%;
            margin: 20px auto;
            box-sizing: border-box;
        }

        .generationDiv {
            min-height: 300px;
            min-width: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            border: 4px solid #ddd;
            cursor: pointer;
            position: relative;
            background-color: #f9f9f9;
        }


        .generationDiv:hover {
            transform: scale(1.03);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        .generatedImage {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
        }

        .dropdownToggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            z-index: 1000;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dropdownToggle:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

        .dropdown {
            position: absolute;
            top: 50px;
            right: 10px;
            display: none;
            background-color: #333;
            border: 1px solid #444;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            padding: 5px;
            width: 150px;
            text-align: left;
        }

        .dropdown button {
            background: none;
            color: #fff;
            border: none;
            padding: 10px;
            text-align: left;
            width: 100%;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .dropdown button:hover {
            background-color: #555;
        }

        .generationPopupContent {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgb(0, 0, 0);
            background-image: linear-gradient(315deg, #006de2 0%, #000000 74%);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            display: none;
        }

        .generatedImage {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
            cursor: pointer;
        }

        .popupGeneratedImage {
            width: auto;
            height: 70vh;
            object-fit: cover;
            border-radius: 10px;
            cursor: pointer;
            margin: 0 auto;
            /* center it: */
            display: block;
        }

        .generationDiv.selected {
            border: 4px solid #ff0000 !important;
        }

        .generationDiv.in-delete-mode {
            cursor: pointer;
            position: relative;
        }

        .generationDiv.in-delete-mode::after {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 3px;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .generationDiv.in-delete-mode.selected::after {
            content: '✓';
            background-color: #ff0000;
            color: #fff;
            text-align: center;
            line-height: 20px;
            font-weight: bold;
        }

        .downloadCurrentPageButton {
            background-color: #0084ff;
            color: #fff;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .downloadCurrentPageButton:hover {
            background-color: #0056b3;
        }
    
        .deleteAllImagesButton {
            background-color: #ff0000;
            color: #fff;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .deleteAllImagesButton:hover {
            background-color: #ff3333;
        }

        .deleteCurrentPageButton {
            background-color: #ff6600;
            color: #fff;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .deleteCurrentPageButton:hover {
            background-color: #ff8533;
        }

        .sticky-menu:hover .menu-button span {
            opacity: 1;
        }
        
        .menu-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .download-button:hover {
            background-color: #0056b3;
        }

        .delete-visible-button:hover {
            background-color: #ff6600;
        }

        .delete-all-button:hover,
        .delete-selected-button:hover {
            background-color: #ff3333;
        }

        .toggle-delete-mode-button:hover {
            background-color: #0084ff;
        }

        .generationDiv.selected {
            border: 4px solid #ff0000 !important;
        }

        .generationDiv.in-delete-mode {
            cursor: pointer;
            position: relative;
        }

        .generationDiv.in-delete-mode::after {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 3px;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .generationDiv.in-delete-mode.selected::after {
            content: '✓';
            background-color: #ff0000;
            color: #fff;
            text-align: center;
            line-height: 20px;
            font-weight: bold;
        }
        
        /* Add a responsive layout for smaller screens */
        @media (max-width: 768px) {
            .sticky-menu {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                max-width: 90%;
                left: 0;
                bottom: auto;
                top: 30%;
            }
            
            .menu-header {
                width: 100%;
                margin-bottom: 5px;
            }
            
            .menu-button {
                padding: 8px;
            }
            
            .menu-button span {
                display: none;
            }
        }

    </style>

    <script>
        function toggleDropdown(id) {
            const dropdown = document.getElementById(`dropdown-${id}`);
            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        }
    </script>

    <!-- Search Box -->
    <details open>
        <summary style="font-size: xx-large;">Search for images by prompt or model</summary>
        <br>
        <input type="text" id="searchInputPrompt" placeholder="Search for prompts.." value="<%= search %>" 
            onkeydown="if (event.keyCode == 13) { search() }" />
        <br><br>
        <select id="searchInputModel" name="model">
            <option value="all" <%= model === 'all' ? 'selected' : '' %>>All Models</option>
            <option value="fluffysonic" <%= model === 'fluffysonic' ? 'selected' : '' %>>(SD 1.5) FluffySonic (Sonic the Hedgehog)</option>
            <option value="realisticVision" <%= model === 'realisticVision' ? 'selected' : '' %>>(SD 1.5) realisticVision (Realstic)</option>    
            <option value="pdxl-autismmix" <%= model === 'pdxl-autismmix' ? 'selected' : '' %>>(PDXL) Autism Mix (2D, 3D)</option>
            <option value="pdxl-sonichasautismmix" <%= model === 'pdxl-sonichasautismmix' ? 'selected' : '' %>>(PDXL) SonicHasAutismMix (SonicDiffusionXL & AutismMix merge)</option>
            <option value="pdxl-ponyrealism" <%= model === 'pdxl-ponyrealism' ? 'selected' : '' %>>(PDXL) Pony Realism (Realistic)</option>
            <option value="pdxl-fluffysonic" <%= model === 'pdxl-fluffysonic' ? 'selected' : '' %>>(PDXL) FluffySonic (Sonic the Hedgehog)</option>
            <option value="illustrious-wai" <%= model === 'illustrious-wai' ? 'selected' : '' %>>(ILLUSTRIOUS) WAI (2d, Anime, Human)</option>
            <option value="illustrious-novafurry" <%= model === 'illustrious-novafurry' ? 'selected' : '' %>>(ILLUSTRIOUS) Nova Furry (2d, 3d, Furry)</option>
            <option value="illustrious-novaanimal" <%= model === 'illustrious-novaanimal' ? 'selected' : '' %>>(ILLUSTRIOUS) Nova Animal (Realistic, 3d, Animal)</option>
        </select>
        &nbsp;&nbsp;
        <select id="searchInputSort" name="sort">
            <option value="newest" <%= sort === 'newest' ? 'selected' : '' %>>Newest First</option>
            <option value="oldest" <%= sort === 'oldest' ? 'selected' : '' %>>Oldest First</option>
        </select>
        <br><br>
        <button onclick="search()">Search</button>
    </details>

    <!-- if the totalUserImages is more than 15000 display a message that future generated images wont be saved: -->

    <% if (totalUserImages >= userProfile?.variables?.userHistoryLimit ?? 5000) { %>
        <h2>You have <%= totalUserImages %> / <%= userProfile?.variables?.userHistoryLimit ?? 5000 %></h2>
        <p>Future generated images will not be saved to your history, please delete some images to make room for more.</p>
    <% } else { %>
        <h2>You have <%= totalUserImages %> / <%= userProfile?.variables?.userHistoryLimit ?? 5000 %></h2>
        <p>Once you reach <%= userProfile?.variables?.userHistoryLimit ?? 5000 %> images, future generated images will not be saved to your history.</p>
    <% } %>

    <div class="generationsGrid">
        <% userHistory.forEach((imageData, index) => { %>
            <div id="<%= imageData.image_id %><%= imageData.account_id %>" class="generationDiv">
                <% const thumbImage = imageData.thumbnailMade 
                    ? imageData.image_url.replace('.png', '-thumb.png') 
                    : imageData.image_url; %>
                <img class="generatedImage" loading="lazy" src="<%= thumbImage %>" 
                    onclick="handleImageClick('<%= imageData.image_id %><%= imageData.account_id %>', event)" />

                <!-- Dropdown toggle button -->
                <button class="dropdownToggle" onclick="toggleDropdown('<%= imageData.image_id %><%= imageData.account_id %>')">⋮</button>

                <!-- Dropdown menu -->
                <div id="dropdown-<%= imageData.image_id %><%= imageData.account_id %>" class="dropdown">
                    <button onclick="deleteImage('<%= imageData.image_id %>-<%= imageData.account_id %>')">Delete</button>
                    <a href="<%= imageData.image_url %>" download>
                        <button>Download</button>
                    </a>
                    <button onclick="openInGenerator('<%= imageData.image_id %><%= imageData.account_id %>')">Open In Generator</button>
                    <button onclick="exportAIData('<%= imageData.image_id %><%= imageData.account_id %>')">Export .aidata</button>
                </div>
            </div>
        <% }); %>
        <!-- Infinite scroll sentinel -->
        <div id="scroll-sentinel" style="height: 20px; grid-column: 1 / -1;"></div>
    </div>
    
    <!-- Loading indicator outside grid -->
    <div id="loadingMoreIndicator" class="loading-indicator" style="display: none;">Loading more images...</div>
    <div id="endMessage" class="end-message" style="display: none;">No more images to load</div>

    <style>
        .loading-indicator {
            text-align: center;
            padding: 20px;
            color: #fff;
            margin: 20px auto;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            max-width: 300px;
        }
        
        .end-message {
            text-align: center;
            padding: 20px;
            color: #aaa;
            margin: 20px auto;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            max-width: 300px;
        }

        /* Sticky menu styling */
        .sticky-menu {
            position: fixed;
            left: 0;
            top: 30%;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 0 10px 10px 0;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease, opacity 0.5s ease;
            min-width: 60px;
            /* When not hovered, make it semi-transparent */
            opacity: 0.6;
        }

        .sticky-menu:hover {
            opacity: 1;
        }

        .menu-header {
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            white-space: nowrap;
        }

        .menu-button {
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background-color 0.3s;
            white-space: nowrap;
        }

        .menu-button i {
            font-size: 1.2rem;
            min-width: 20px;
            text-align: center;
        }

        .menu-button span {
            display: inline-block;
            opacity: 1;
            font-weight: 500;
        }

        .sticky-menu:hover .menu-button span {
            opacity: 1;
        }
    </style>

    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <script>
        // Add a flag to track if we're in delete mode
        let deleteMode = false;
        let selectedImages = [];
        // Add variables for infinite scrolling
        let currentPage = <%= page %>;
        let totalPages = <%= totalPages %>;
        let isLoading = false;
        let hasReachedEnd = <%= page >= totalPages %>;
        let currentSearch = "<%= search %>";
        let currentModel = "<%= model %>";
        let currentSort = "<%= sort || 'newest' %>";
        let userHistoryLimit = <%= userProfile?.variables?.userHistoryLimit ?? 5000 %>;

        function toggleDeleteMode() {
            deleteMode = !deleteMode;
            
            // Update button text and icon
            const toggleButton = document.getElementById('toggleDeleteModeButton');
            if (deleteMode) {
                toggleButton.querySelector('i').className = 'fas fa-times-circle';
                toggleButton.querySelector('span').textContent = 'Exit Select';
            } else {
                toggleButton.querySelector('i').className = 'fas fa-check-square';
                toggleButton.querySelector('span').textContent = 'Select Mode';
            }
            
            // Show/hide buttons
            document.getElementById('deleteSelectedButton').style.display = deleteMode ? 'flex' : 'none';
            document.getElementById('downloadSelectedButton').style.display = deleteMode ? 'flex' : 'none';
            document.getElementById('deleteAllButton').style.display = deleteMode ? 'none' : 'flex';
            
            // Reset selected images if exiting
            if (!deleteMode) {
                selectedImages = [];
                updateSelectedCount();
            }
            
            // Update all image divs, including those loaded dynamically
            const imageDivs = document.querySelectorAll('.generationDiv');
            imageDivs.forEach(div => {
                if (deleteMode) {
                    div.classList.add('in-delete-mode');
                } else {
                    div.classList.remove('in-delete-mode');
                    div.classList.remove('selected');
                }
            });
        }

        function toggleImageSelection(imageId, event) {
            if (!deleteMode) return;
            
            // Prevent the popup from showing
            event.preventDefault();
            event.stopPropagation();
            
            const imageDiv = document.getElementById(imageId);
            const index = selectedImages.indexOf(imageId);
            
            if (index === -1) {
                // Add to selection
                selectedImages.push(imageId);
                imageDiv.classList.add('selected');
            } else {
                // Remove from selection
                selectedImages.splice(index, 1);
                imageDiv.classList.remove('selected');
            }
            
            updateSelectedCount();
        }

        function updateSelectedCount() {
            const count = selectedImages.length;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('downloadCount').textContent = count;
            
            // Enable/disable buttons based on selection count
            const downloadButton = document.getElementById('downloadSelectedButton');
            const deleteButton = document.getElementById('deleteSelectedButton');
            
            if (count > 0) {
                downloadButton.disabled = false;
                deleteButton.disabled = false;
            } else {
                downloadButton.disabled = true;
                deleteButton.disabled = true;
            }
        }
        
        // Function to download selected images
        async function downloadSelectedImages() {
            if (selectedImages.length === 0) {
                alert('No images selected. Please select images first.');
                return;
            }
            
            // Extract the image IDs from the selected image divs
            const imageIds = selectedImages.map(imageId => {
                // Get the actual image_id from masterImageData
                return masterImageData[imageId].image_id;
            });
            
            // Show a loading indicator
            const loadingIndicator = document.getElementById('loadingMoreIndicator');
            loadingIndicator.innerHTML = `Preparing ${imageIds.length} images for download...`;
            loadingIndicator.style.display = 'block';
            
            try {
                const response = await fetch('/image-history/download-page', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ imageIds })
                });
                
                if (response.ok) {
                    // Extract filename from response headers if possible
                    const disposition = response.headers.get('Content-Disposition');
                    const filename = disposition
                        ? disposition.split('filename=')[1].replace(/"/g, '')
                        : 'jscammie-selected-images.zip';
                    
                    // Convert response to blob and create a download link
                    const blob = await response.blob();
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(blob);
                    downloadLink.download = filename;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    loadingIndicator.innerHTML = 'Download complete!';
                    setTimeout(() => {
                        loadingIndicator.style.display = 'none';
                    }, 3000);
                } else {
                    loadingIndicator.innerHTML = 'Error preparing download. Please try again.';
                    setTimeout(() => {
                        loadingIndicator.style.display = 'none';
                    }, 3000);
                }
            } catch (error) {
                console.error('Error downloading images:', error);
                loadingIndicator.innerHTML = 'Error downloading images. Please try again.';
                setTimeout(() => {
                    loadingIndicator.style.display = 'none';
                }, 3000);
            }
        }

        function search() {
            const prompt = document.getElementById('searchInputPrompt').value;
            const model = document.getElementById('searchInputModel').value;
            const sort = document.getElementById('searchInputSort').value;
            const query = new URLSearchParams({
                search: prompt,
                model,
                sort,
                page: 1, // Always reset to the first page
            });
            window.location.href = `/image-history?${query.toString()}`;
        }
        
        // Helper function to get images currently visible in the viewport
        function getVisibleImages() {
            const imageDivs = document.querySelectorAll('.generationDiv');
            const viewportHeight = window.innerHeight;
            const viewportTop = window.scrollY;
            const viewportBottom = viewportTop + viewportHeight;
            
            // Filter images that are visible in the viewport
            return Array.from(imageDivs).filter(div => {
                const rect = div.getBoundingClientRect();
                const divTop = rect.top + viewportTop;
                const divBottom = rect.bottom + viewportTop;
                
                // Check if at least part of the image is in the viewport
                return (divTop < viewportBottom && divBottom > viewportTop);
            });
        }

        // Function to delete visible images
        async function deleteVisibleImages() {
            // ask if they are sure they want to delete currently visible images:
            let options = {
                message: 'Are you sure you want to delete all currently visible images?',
                question: true,
                options: {
                    yes: function() {
                        console.log("Yes clicked");
                    },
                    no: function() {
                        console.log("No clicked");
                    }
                }
            }

            let alertResponse = await globalAlert(options);

            if (alertResponse == 'no') {
                return;
            }
            
            // Get all visible images in the viewport
            const visibleImages = getVisibleImages();
            if (visibleImages.length === 0) {
                alert('No visible images found');
                return;
            }
            
            // Show a loading indicator
            const loadingIndicator = document.getElementById('loadingMoreIndicator');
            loadingIndicator.innerHTML = `Deleting ${visibleImages.length} images...`;
            loadingIndicator.style.display = 'block';
            
            let promises = [];

            // Delete each visible image
            visibleImages.forEach(imageDiv => {
                const image_id = imageDiv.id.split(/(?=[A-Z])/)[0];
                
                // Animate the image div disappearing
                imageDiv.style.transition = 'opacity 0.5s';
                imageDiv.style.opacity = 0;
                
                // Add the deletion promise
                promises.push(fetch('/image-history/delete-image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image_id: image_id,
                    })
                }));
            });
            
            // Wait for all deletions to complete
            Promise.all(promises)
            .then(() => {
                // Remove the elements from the DOM
                setTimeout(() => {
                    visibleImages.forEach(imageDiv => {
                        imageDiv.remove();
                    });
                    loadingIndicator.style.display = 'none';
                }, 500);
            })
            .catch(error => {
                console.error('Error deleting images:', error);
                loadingIndicator.innerHTML = 'Error deleting images';
                setTimeout(() => {
                    loadingIndicator.style.display = 'none';
                }, 3000);
            });
        }
        
        // Function for improved infinite scrolling
        async function loadMoreImages() {
            if (isLoading || hasReachedEnd) return;
            
            isLoading = true;
            currentPage++;
            
            // Show loading indicator
            document.getElementById('loadingMoreIndicator').style.display = 'block';
            
            try {
                const response = await fetch(`/image-history?page=${currentPage}&search=${encodeURIComponent(currentSearch)}&model=${currentModel}&sort=${currentSort}&ajax=true`);
                const data = await response.json();
                
                if (data.images.length === 0) {
                    hasReachedEnd = true;
                    document.getElementById('loadingMoreIndicator').style.display = 'none';
                    document.getElementById('endMessage').style.display = 'block';
                    return;
                }
                
                // Get the sentinel element
                const sentinel = document.getElementById('scroll-sentinel');
                
                // Add images to the grid
                data.images.forEach(imageData => {
                    // Add to masterImageData
                    const imageId = imageData.image_id + imageData.account_id;
                    masterImageData[imageId] = {
                        prompt: imageData.prompt,
                        negative_prompt: imageData.negative_prompt,
                        model: imageData.model,
                        aspect_ratio: imageData.aspect_ratio,
                        loras: imageData.loras,
                        lora_strengths: imageData.lora_strengths,
                        steps: imageData.steps,
                        cfg: imageData.cfg,
                        seed: imageData.seed,
                        image_url: imageData.image_url,
                        image_id: imageData.image_id,
                        uploadedToBooru: imageData.uploadedToBooru,
                        thumbnailMade: imageData.thumbnailMade,
                    };
                    
                    // Create HTML for the new image
                    const thumbImage = imageData.thumbnailMade 
                        ? imageData.image_url.replace('.png', '-thumb.png') 
                        : imageData.image_url;
                    
                    const div = document.createElement('div');
                    div.id = imageId;
                    div.className = 'generationDiv' + (deleteMode ? ' in-delete-mode' : '');
                    div.innerHTML = `
                        <img class="generatedImage" loading="lazy" src="${thumbImage}" 
                            onclick="handleImageClick('${imageId}', event)" />
                        <button class="dropdownToggle" onclick="toggleDropdown('${imageId}')">⋮</button>
                        <div id="dropdown-${imageId}" class="dropdown">
                            <button onclick="deleteImage('${imageData.image_id}-${imageData.account_id}')">Delete</button>
                            <a href="${imageData.image_url}" download>
                                <button>Download</button>
                            </a>
                            <button onclick="openInGenerator('${imageId}')">Open In Generator</button>
                            <button onclick="exportAIData('${imageId}')">Export .aidata</button>
                        </div>
                    `;
                    
                    // Insert before the sentinel
                    document.querySelector('.generationsGrid').insertBefore(div, sentinel);
                });
                
            } catch (error) {
                console.error('Error loading more images:', error);
                document.getElementById('loadingMoreIndicator').innerHTML = 'Error loading images. <button onclick="loadMoreImages()">Retry</button>';
            } finally {
                isLoading = false;
                document.getElementById('loadingMoreIndicator').style.display = 'none';
                
                // If we still have more pages, preload more when appropriate
                if (!hasReachedEnd && document.documentElement.scrollHeight - window.innerHeight - window.scrollY < 1000) {
                    // If we're still close to the bottom after loading, load more
                    setTimeout(loadMoreImages, 500);
                }
            }
        }
        
        // Intersection Observer for infinite scrolling
        function setupInfiniteScroll() {
            const sentinel = document.getElementById('scroll-sentinel');
            
            const observer = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting && !isLoading && !hasReachedEnd) {
                    loadMoreImages();
                }
            }, {
                // Start loading when the sentinel is 2000px away from viewport
                rootMargin: '2000px 0px'
            });
            
            observer.observe(sentinel);
            
            // Also check on scroll to handle cases where the content might not be tall enough
            window.addEventListener('scroll', () => {
                const scrollPosition = window.scrollY + window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
                
                // If we're within 2500px of the bottom, load more
                if (documentHeight - scrollPosition < 2500 && !isLoading && !hasReachedEnd) {
                    loadMoreImages();
                }
            });
        }
        
        // Setup scroll detection on page load
        document.addEventListener('DOMContentLoaded', function() {
            setupInfiniteScroll();
            updateMenuPosition();
            
            // Make sure the menu is initially visible
            setTimeout(updateMenuPosition, 500);
        });
        
        // Function to update the vertical position of the sticky menu on scroll
        function updateMenuPosition() {
            const stickyMenu = document.querySelector('.sticky-menu');
            if (!stickyMenu) return;
            
            const viewportHeight = window.innerHeight;
            const scrollY = window.scrollY;
            
            // Calculate ideal position (center of viewport)
            let idealPosition = scrollY + (viewportHeight / 2);
            
            // Apply the transform to keep it vertically centered in the current viewport
            stickyMenu.style.top = '50%';
            stickyMenu.style.transform = 'translateY(-50%)';
        }

        // Add scroll listener for menu positioning
        window.addEventListener('scroll', updateMenuPosition);
        window.addEventListener('resize', updateMenuPosition);
    </script>

    <div class="generationsControls" id="generationsControls"></div>

    <!-- get partials/_footer: -->
    <%- include('../partials/_footer') %>
    
    <!-- Sticky menu at the end of the body for better positioning -->
    </div>
    <div class="sticky-menu">
        <div class="menu-header">Actions</div>
        <button id="downloadSelectedButton" class="menu-button download-button" onclick="downloadSelectedImages()" title="Download selected images" style="display: none;">
            <i class="fas fa-download"></i>
            <span>Download (<span id="downloadCount">0</span>)</span>
        </button>
        <button id="deleteAllButton" class="menu-button delete-all-button" onclick="deleteAllImages()" title="Delete all your images">
            <i class="fas fa-trash-alt"></i>
            <span>Delete All</span>
        </button>
        <button id="toggleDeleteModeButton" class="menu-button toggle-delete-mode-button" onclick="toggleDeleteMode()" title="Select multiple images">
            <i class="fas fa-check-square"></i>
            <span>Select Mode</span>
        </button>
        <button id="deleteSelectedButton" class="menu-button delete-selected-button" style="display: none;" onclick="deleteSelectedImages()" title="Delete selected images">
            <i class="fas fa-trash"></i>
            <span>Delete (<span id="selectedCount">0</span>)</span>
        </button>
    </div>
    
    <script>
        // Position the sticky menu based on scroll
        let lastKnownScrollPosition = 0;
        let ticking = false;
        
        function positionMenu(scrollPos) {
            const menu = document.querySelector('.sticky-menu');
            if (!menu) return;
            
            // Get the window height and set position at 30% down from the top of the viewport
            const windowHeight = window.innerHeight;
            const topPosition = Math.floor(windowHeight * 0.8);
            
            menu.style.top = topPosition + 'px';
            menu.style.position = 'fixed';
        }
        
        // Run on scroll
        document.addEventListener('scroll', function(e) {
            lastKnownScrollPosition = window.scrollY;
            
            if (!ticking) {
                window.requestAnimationFrame(function() {
                    positionMenu(lastKnownScrollPosition);
                    ticking = false;
                });
                
                ticking = true;
            }
        });
        
        // Run on resize
        window.addEventListener('resize', function() {
            positionMenu(window.scrollY);
        });
        
        // Initial positioning
        document.addEventListener('DOMContentLoaded', function() {
            positionMenu(window.scrollY);
            // Run it again after a short delay to ensure everything is loaded
            setTimeout(function() {
                positionMenu(window.scrollY);
            }, 500);
        });
        
        // Call it once right away
        positionMenu(window.scrollY);
    </script>

    <script>
        async function deleteSelectedImages() {
            if (selectedImages.length === 0) {
                return;
            }
            
            const options = {
                message: `Are you sure you want to delete ${selectedImages.length} selected images?`,
                question: true,
                options: {
                    yes: function() { console.log("Yes clicked"); },
                    no: function() { console.log("No clicked"); }
                }
            };
            
            const alertResponse = await globalAlert(options);
            if (alertResponse === 'no') {
                return;
            }
            
            // Show loading state
            const deleteButton = document.getElementById('deleteSelectedButton');
            const originalText = deleteButton.innerHTML;
            deleteButton.innerHTML = 'Deleting...';
            deleteButton.disabled = true;
            
            // Create an array of promises for each deletion
            const promises = selectedImages.map(imageId => {
                // Get the actual image_id from masterImageData
                const image_id = masterImageData[imageId].image_id;
                
                // Animate the div fading out
                const imageDiv = document.getElementById(imageId);
                if (imageDiv) {
                    imageDiv.style.transition = 'opacity 0.5s';
                    imageDiv.style.opacity = 0;
                }
                
                // Return the promise for the fetch request
                return fetch('/image-history/delete-image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image_id: image_id
                    })
                });
            });
            
            // Wait for all deletions to complete
            Promise.all(promises)
                .then(() => {
                    // Exit delete mode and remove elements
                    deleteMode = false;
                    toggleDeleteMode();
                    
                    // Remove deleted elements from DOM after animation
                    setTimeout(() => {
                        selectedImages.forEach(imageId => {
                            const element = document.getElementById(imageId);
                            if (element) element.remove();
                        });
                        selectedImages = [];
                        updateSelectedCount();
                        deleteButton.innerHTML = originalText;
                        deleteButton.disabled = false;
                    }, 500);
                })
                .catch(error => {
                    console.error('Error deleting images:', error);
                    // Reset button state
                    deleteButton.innerHTML = originalText;
                    deleteButton.disabled = false;
                });
        }
    </script>

    <script>
        async function deleteAllImages() {
            // Show confirmation dialog
            const options = {
                message: 'Are you sure you want to delete ALL of your images? This action cannot be undone.',
                question: true,
                options: {
                    yes: function() { console.log("Yes clicked"); },
                    no: function() { console.log("No clicked"); }
                }
            };
            
            const alertResponse = await globalAlert(options);
            if (alertResponse === 'no') {
                return;
            }
            
            // Show loading indicator
            const loadingIndicator = document.getElementById('loadingMoreIndicator');
            loadingIndicator.innerHTML = 'Deleting all images...';
            loadingIndicator.style.display = 'block';
            
            try {
                // Send request to delete all images
                const response = await fetch('/image-history/delete-all-images', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    // Clear the grid
                    const generationsGrid = document.querySelector('.generationsGrid');
                    const sentinel = document.getElementById('scroll-sentinel');
                    
                    // Keep only the sentinel element
                    generationsGrid.innerHTML = '';
                    generationsGrid.appendChild(sentinel);
                    
                    // Reset masterImageData
                    masterImageData = {};
                    
                    loadingIndicator.innerHTML = 'All images deleted successfully';
                    
                    // Update image count display
                    const countDisplay = document.querySelector('h2');
                    if (countDisplay) {
                        countDisplay.textContent = 'You have 0 / ' + userHistoryLimit;
                    }
                } else {
                    loadingIndicator.innerHTML = 'Error deleting images: ' + (data.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error deleting all images:', error);
                loadingIndicator.innerHTML = 'Error deleting images. Please try again.';
            } finally {
                // Hide loading indicator after 3 seconds
                setTimeout(() => {
                    loadingIndicator.style.display = 'none';
                }, 3000);
            }
        }
    </script>
</body>
</html>